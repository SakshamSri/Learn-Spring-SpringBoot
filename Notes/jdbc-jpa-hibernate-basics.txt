"All below notes are according to Udemy tutorial : Master Hibernate and JPA with Spring Boot in 100 Steps.
Course : Section 3 onwards
Corresponding Github Code Repo : Learn-Spring-SpringBoot/Learn-jdbc-jpa/Learn-jdbc-jpa/"

before springjdbc, even a single query line will be huge because of
1) get connection
2) prepare statement
3) execute it
4) iterate through the result
5) add try catch everywhere

with spring jdbc, we dont need to do any of this, all done by spring boot. we only need to execute the query and get back the result as the bean.

H2 -> In memory database

if we add a data.sql file in main/resources, springboot will use that file to initialize the h2 (because if you kill the server, database gets deleted and then everytime you need to add tables and stuff so this file will automatically do the job on server boot up)

@Repository -> marks that class as repository.
A repository is a mechanism for encapsulating storage, retrieval, and search behavior on the database

JdbcTemplate -> to execute the query, it automatically creates a connection with the database

JdbcTemplate.query -> we can pass a beanpropertyrowmapper which will automatically map the table to the bean we will provide.
if using beanpropertyrowmapper, need to have an empty contr present in the bean

if your defined class name or field names are different from the table then you can define your own RowMapper.
and map the table row columns with the corresponding class fields.

implementing CommandLineRunner in SpringBootApplication -> basically will execute the code, as soon as application context is ready, in CommandLineRunner (run method).

H2AutoConfiguration requires console.enabled plus WebServlet class present
DataSourceAutoConfiguration requires DataSource class
JdbcTemplateAutoConfiguration requires DataSource class and a primary bean

JPA standardizes ORM (object relational mapping)
Hibernate is the implementation of JPA (there are other implementations of JPA as well)

for JPA, we add Repository and Transaction because we can have multiple transactions and we want either to fail all or pass all.
Typically, transaction is managed at business service level than respository level.
If we are making changes to the db, we need to add @Transaction. (any method or sub called methods or UT)

Entity Manager -> manages the entities
all operations that we do are stored inside the PersistentContext for which Entity Manager is the interface.

So Hibernate actually creates the schema for us from the entity that we define so we dont need to create table everytime in data.sql

Hibernate creates a sequence (sql) and uses that seq to assign id automatically if @GeneratedValue is added.

findall (select * from table) method is not defined in JPA so we use JPQL namedquery.
JPQL uses entities instead of table names.

deleting data is transacational.

Entity Manager : persits vs merge -> https://stackoverflow.com/questions/1069992/jpa-entitymanager-why-use-persist-over-merge/

Entity Manager ->
perist - will track the entity (the entity fields will be updated but not sent to db) but actual update to db is sent only after flush() or automatically commit on method end. PersistentContext is the one handling all these entities.

flush - EntityManager.persist() makes an entity persistent whereas EntityManager.flush() actually runs the query on your database. So, when you call EntityManager.flush(), queries for inserting/updating/deleting associated entities are executed in the database. Any constraint failures (column width, data types, foreign key) will be known at this time. The concrete behaviour depends on whether flush-mode is AUTO or COMMIT. AUTO will force the changes to that entity to be flushed before the next SELECT execution(for eg). If it's set to COMMIT the persitence of the data to the underlying database will be delayed when the transaction is commited.

detach(Entity) - detach the entity so that it is not persisted. Anymore changes to entity will not be reflected in database until merge is called.

clear - detach all the entities within the method.

refresh(Entity) - reverts the entity values to the values that is in the db. So, any value changes made to entity after flush or commit will be lost and last updated value from db is fetched and set to the entity.

JPQL -
queries written on entities

@CreationTimestamp -> when row was created
@UpdateTimestamp -> when row was last updated

@NamedQuery -> no need to code it again, once define above entity and use it anywhere
For multiple named queries, use @NamedQueries

Native Queries -> direct sql queries in jpa (use tables instead of entities)
When using native queries, PersistentContext is not involved here so if using entites we need to refresh to get latest values from db

foreign key -> primary key in different table
student entity has passport id -> student table is owning the relationship

for OnetoOne -> details are Eager Fetched meaning if student data is retrieved then passport data is also retrieved with it because Student OnetoOne Passport.

To avoid this we can define in passport field in student entity, the fetchtype=lazy
With this, now when we do em.find it will only fetch student details.
And, if we try to do student.getpassport(), it will throw error because there wont be anymore transaction. Session ended on find student.
We can avoid this session ending by adding @Transactional to that method. It will prevent session from ending method exit, then can call student.getpassport() and it will again run the query to fetch passport details.

mappedBy ->
Student table can have passportid column and passport table can have studentid column but that will make it redundant.
So, we make one the owner of the relationship.
We add mappedBy in the @OnetoOne to the not-owning entity in the relationship.
Here, we make the Student the owner, so we add mappedBy="passport" in Passport entity.
This way we can get the student from the passport entity but no need to maintain student id column.
Called bidirectional navigation.

Hibernate waits until last step to push the entity to the db
Because if some error occurs in the transaction then we need to roll back the db changes. So, if we wait till last step, we can avoid this rollback.
And, even if we flush mid transaction, then also everything will be roll backed if some error occurs in the transaction.
This is because the whole thing is a transaction so its either 1 or 0.


@manytoone @onetomany ->
Course can have x reviews but review can be associated with only 1 Course
So Review table will have a course id (course table cannot have review id because one course can have multiple review ids and that will lead to row duplication)
Review entity will be the owning one relationship.
@OneToMany = current entity should be one and is different than owning the relationship.

If we persist before setting up the relationship, then first insert into review is made with blank course id and then an update review is sent to update the course id.

Fetch Type defaults for both hibernate and JPA latest ->
OneToMany: LAZY
ManyToOne: EAGER
ManyToMany: LAZY
OneToOne: EAGER

**ToOne is always EAGER

@ManyToMany ->
Create a join table that maps student id to course id or vice versa (because adding only in one table will make the relationship data become redundant)
If add ManyToMany on both entities, then in db there will be 2 tables course_student and student_course
So, we need to make one the owning table to avoid duplication of tables in db.
Also since, we will be using a join table so making any one the owning is fine. (owning by adding mappedBy to the other)

@JoinTable -> customize the join table created by manytomany, annontation added on owning side

Inheritance Relationship -> 4 methods

M1=Single Table Inheritance - Suppose employee has 2 sub class called fulltime and parttime, so we can use @Inheritance and use InheritanceType.SINGLE(default type) to save both employee types data in one table instead of creating 2 different tables and then joining them. It created one more column(DTYPE, can be customized with @DiscriminatorColumn) that differentiates whether the row is for fulltime or parttime. This is good for performance since there is only one table to look for data and fetch. But, data integrity is hampered since now hourlywage and salary needs to be made nullable (as one is null for other type). This can lead to data invalidity because now someone can put hourlywage as null for parttime employee which should not allowed (wage is important cannot be null).

M2=Table per class - Individual tables are created for Concrete classes (Employee is abstract so no table for employee but FullTime and PartTime are concrete so one table each is created for them and data is stored in different tables). Even though 2 tables will be created but that will be internal so no code changes are needed. We just need to insert for Employee. When we are retrieving data for all Employee, then internally from both tables data is retrieved and then union is done. Performance is ok (since union is not an issue and data is fetched from individual table) and data integrity is maintained. But, the issue is there is repitition of columns. The common columns are repeated in both tables and there might be a lot of columns that are common and those will be repeated.

M3=Joined - Employe has own table (common to other both tables columns only), FullTime has own table(own data column with id from Employee(fk)) and PartTime has own table(own data column with id from Employee(fk)). To retrieve data, 3 table joins were made so performance is low. But, data integrity is best since all have different tables and no data replication.

M4=Mapped Super Class - (Dont use @Inheritance) Use @MappedSuperClass. When a class is @MappedSuperClass, it cannot be an @Entity. So, no table for Employee itself. We cannot use "select e from Employee e" since Employee itself is not an Entity. So, to retrieve data, we need to retrieve all data individually from FullTime table and PartTime table.

M1 performance best at the cost of data integrity
M2 repeating columns so NO (3NF doesnt allow this)
M3 data integrity best at the cost of performance
M4 repeating columns so NO (3NF doesnt allow this)
