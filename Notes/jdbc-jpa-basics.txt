"All below notes are according to Udemy tutorial : Master Hibernate and JPA with Spring Boot in 100 Steps.
Course : Section 3
Corresponding Github Code Repo : Learn-Spring-SpringBoot/Learn-jdbc-jpa/Learn-jdbc-jpa/"

before springjdbc, even a single query line will be huge because of
1) get connection
2) prepare statement
3) execute it
4) iterate through the result
5) add try catch everywhere

with spring jdbc, we dont need to do any of this, all done by spring boot. we only need to execute the query and get back the result as the bean.

H2 -> In memory database

if we add a data.sql file in main/resources, springboot will use that file to initialize the h2 (because if you kill the server, database gets deleted and then everytime you need to add tables and stuff so this file will automatically do the job on server boot up)

@Repository -> marks that class as repository.
A repository is a mechanism for encapsulating storage, retrieval, and search behavior on the database

JdbcTemplate -> to execute the query, it automatically creates a connection with the database

JdbcTemplate.query -> we can pass a beanpropertyrowmapper which will automatically map the table to the bean we will provide.
if using beanpropertyrowmapper, need to have an empty contr present in the bean

if your defined class name or field names are different from the table then you can define your own RowMapper.
and map the table row columns with the corresponding class fields.

implementing CommandLineRunner in SpringBootApplication -> basically will execute the code, as soon as application context is ready, in CommandLineRunner (run method).

H2AutoConfiguration requires console.enabled plus WebServlet class present
DataSourceAutoConfiguration requires DataSource class
JdbcTemplateAutoConfiguration requires DataSource class and a primary bean

JPA standardizes ORM (object relational mapping)
Hibernate is the implementation of JPA (there are other implementations of JPA as well)

for JPA, we add Repository and Transaction because we can have multiple transactions and we want either to fail all or pass all.
Typically, transaction is managed at business service level than respository level.

Entity Manager -> manages the entities
all operations that we do are stored inside the PersistentContext for which Entity Manager is the interface.

So Hibernate actually creates the schema for us from the entity that we define so we dont need to create table everytime in data.sql

Hibernate creates a sequence (sql) and uses that seq to assign id automatically if @GeneratedValue is added.

findall (select * from table) method is not defined in JPA so we use JPQL namedquery.
JPQL uses entities instead of table names.

deleting data is transacational.

Entity Manager : persits vs merge -> https://stackoverflow.com/questions/1069992/jpa-entitymanager-why-use-persist-over-merge/

Entity Manager ->
perist - will track the entity (the entity fields will be updated but not sent to db) but actual update to db is sent only after flush() or automatically commit on method end. PersistentContext is the one handling all these entities.

flush - EntityManager.persist() makes an entity persistent whereas EntityManager.flush() actually runs the query on your database. So, when you call EntityManager.flush(), queries for inserting/updating/deleting associated entities are executed in the database. Any constraint failures (column width, data types, foreign key) will be known at this time. The concrete behaviour depends on whether flush-mode is AUTO or COMMIT. AUTO will force the changes to that entity to be flushed before the next SELECT execution(for eg). If it's set to COMMIT the persitence of the data to the underlying database will be delayed when the transaction is commited.

detach(Entity) - detach the entity so that it is not persisted. Anymore changes to entity will not be reflected in database until merge is called.

clear - detach all the entities within the method.

refresh(Entity) - reverts the entity values to the values that is in the db. So, any value changes made to entity after flush or commit will be lost and last updated value from db is fetched and set to the entity.

JPQL -
queries written on entities

@CreationTimestamp -> when row was created
@UpdateTimestamp -> when row was last updated

@NamedQuery -> no need to code it again, once define above entity and use it anywhere
For multiple named queries, use @NamedQueries

Native Queries -> direct sql queries in jpa (use tables instead of entities)
When using native queries, PersistentContext is not involved here so if using entites we need to refresh to get latest values from db
